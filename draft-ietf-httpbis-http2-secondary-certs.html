<!DOCTYPE html>
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Secondary Certificate Authentication in HTTP/2</title><script>
function anchorRewrite() {
  map = { };
  if (window.location.hash.length >= 1) {
    var fragid = window.location.hash.substr(1);
    if (fragid) {
      if (! document.getElementById(fragid)) {
        var prefix = "rfc.";
        var mapped = map[fragid];
        if (mapped) {
          window.location.hash = mapped;
        } else if (fragid.indexOf("section-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(8);
        } else if (fragid.indexOf("appendix-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(9);
        } else if (fragid.indexOf("s-") == 0) {
          var postfix = fragid.substring(2);
          if (postfix.startsWith("abstract")) {
            window.location.hash = prefix + postfix;
          } else if (postfix.startsWith("note-")) {
            window.location.hash = prefix + "note." + postfix.substring(5);
          } else {
            window.location.hash = prefix + "section." + postfix;
          }
        } else if (fragid.indexOf("p-") == 0) {
          var r = fragid.substring(2);
          var p = r.indexOf("-");
          if (p >= 0) {
            window.location.hash = prefix + "section." + r.substring(0, p) + ".p." + r.substring(p + 1);
          }
        }
      }
    }  
  }
}
window.addEventListener('hashchange', anchorRewrite);
window.addEventListener('DOMContentLoaded', anchorRewrite);
</script>
<style type="text/css">/*<![CDATA[*/

body {
  font: 16px "Helvetica Neue","Open Sans",Helvetica,Calibri,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 24px;
  margin: 75px auto;
  max-width: 624px;
  padding: 0 5px;
}

.title, .filename, h1, h2, h3, h4, h5 {
  font: 16px "Roboto Condensed","Helvetica Neue","Open Sans",Helvetica,Calibri,sans-serif;
  font-size-adjust: 0.5;
  font-weight: bold;
  color: #333;
  line-height: 100%;
  margin: 1.2em 0 0.3em;
}
.title, #rfc\.title h1 { font-size: 32px; }
h1, section h1, h2, section h2, section h3, nav h2 { font-size: 20px; }
h3, section h4, h4, section h5 { font-size: 16px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header, table#rfc\.headerblock {
  width: 100%;
}
table.header td, table#rfc\.headerblock td {
  border: none;
  background-color: transparent;
  color: black;
  padding: 0;
}
.filename {
  display: block;
  color: rgb(119, 119, 119);
  font-size: 20px;
  font-weight: normal;
  line-height: 100%;
  margin: 10px 0 32px;
}
#rfc\.abstract+p, #rfc\.abstract+p code, #rfc\.abstract+p samp, #rfc\.abstract+p tt {
  font-size: 20px;
  line-height: 28px;
}

samp, tt, code, pre, span.tt {
  font-size: 13.5px;
  font-family: Consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure, caption {
  font-style: italic;
  margin: 0 1.5em;
  text-align: left;
}

address {
  margin: 16px 2px;
  line-height: 20px;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn, address b {
  font-weight: normal;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}
hr.noprint {
  display: none;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

p, ol, ul, li {
  padding: 0;
}
p {
  margin: 0.5em 0;
}
ol, ul {
  margin: 0.2em 0 0.2em 2em;
}
li {
  margin: 0.2em 0;
}
address {
  font-style: normal;
}

ul.toc ul {
  margin: 0 0 0 2em;
}
ul.toc li {
  list-style: none;
  margin: 0;
}

@media screen and (min-width: 924px) {
  body {
    padding-right: 350px;
  }
  body>ul.toc, body>#rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    z-index: 1;
    overflow: auto;
    overscroll-behavior: contain;
  }
  body>#rfc\.toc {
    top: 55px;
  }
  body>ul.toc {
    top: 100px;
  }

  ul.toc {
    margin: 0 0 0 4px;
    font-size: 12px;
    line-height: 20px;
  }
  ul.toc ul {
    margin-left: 1.2em;
  }
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>
  <meta name="viewport" content="initial-scale=1.0">
<link rel="Contents" href="#rfc.toc"><link rel="Author" href="#rfc.authors"><link rel="License" href="#rfc.copyrightnotice"><link rel="Chapter" title="1 Introduction" href="#rfc.section.1"><link rel="Chapter" title="2 Discovering Additional Certificates at the HTTP/2 Layer" href="#rfc.section.2"><link rel="Chapter" title="3 Certificates Frames for HTTP/2" href="#rfc.section.3"><link rel="Chapter" title="4 Indicating Failures During HTTP-Layer Certificate Authentication" href="#rfc.section.4"><link rel="Chapter" title="5 Required Domain Certificate Extension" href="#rfc.section.5"><link rel="Chapter" title="6 Security Considerations" href="#rfc.section.6"><link rel="Chapter" title="7 IANA Considerations" href="#rfc.section.7"><link rel="Chapter" title="8 References" href="#rfc.section.8"><link rel="Appendix" title="A Change Log" href="#rfc.section.A"><link rel="Appendix" title="Acknowledgements" href="#rfc.section.unnumbered-1"><meta name="viewport" content="initial-scale=1"><meta name="generator" content="http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.1124, 2019/05/16 05:56:11, XSLT vendor: libxslt http://xmlsoft.org/XSLT/, via: https://github.com/cabo/kramdown-rfc2629 version 1.2.11"><meta name="keywords" content="Internet-Draft"><link rel="schema.dcterms" href="http://purl.org/dc/terms/"><meta name="dcterms.creator" content="Bishop, M."><meta name="dcterms.creator" content="Sullivan, N."><meta name="dcterms.creator" content="Thomson, M."><meta name="dcterms.issued" content="2019-07-05"><meta name="dcterms.abstract" content="A use of TLS Exported Authenticators is described which enables HTTP/2 clients and servers to offer additional certificate-based credentials after the connection is established. The means by which these credentials are used with requests is defined."><meta name="description" content="A use of TLS Exported Authenticators is described which enables HTTP/2 clients and servers to offer additional certificate-based credentials after the connection is established. The means by which these credentials are used with requests is defined."></head><body><header><table class="header" id="rfc.headerblock"><tbody><tr><td class="left">HTTP Working Group</td><td class="right">M. Bishop</td></tr><tr><td class="left">Internet-Draft</td><td class="right">Akamai</td></tr><tr><td class="left">Intended status: Standards Track</td><td class="right">N. Sullivan</td></tr><tr><td class="left">Expires: January 6, 2020</td><td class="right">Cloudflare</td></tr><tr><td class="left"></td><td class="right">M. Thomson</td></tr><tr><td class="left"></td><td class="right">Mozilla</td></tr><tr><td class="left"></td><td class="right">July 5, 2019</td></tr></tbody></table><div id="rfc.title"><h1>Secondary Certificate Authentication in HTTP/2</h1><div class="filename"><a href="https://datatracker.ietf.org/doc/draft-ietf-httpbis-http2-secondary-certs" class="smpl">draft-ietf-httpbis-http2-secondary-certs-latest</a></div></div></header><section id="rfc.abstract"><h2><a href="#rfc.abstract">Abstract</a></h2><div id="rfc.abstract.p.1"><p>A use of TLS Exported Authenticators is described which enables HTTP/2 clients and servers to offer additional certificate-based credentials after the connection is established. The means by which these credentials are used with requests is defined.</p></div></section><section id="rfc.note.1" class="note"><h2><a href="#rfc.note.1">Note to Readers</a></h2><div id="rfc.note.1.p.1"><p>Discussion of this draft takes place on the HTTP working group mailing list (ietf-http-wg@w3.org), which is archived at <a href="https://lists.w3.org/Archives/Public/ietf-http-wg/">https://lists.w3.org/Archives/Public/ietf-http-wg/</a>.</p></div><div id="rfc.note.1.p.2"><p>Working Group information can be found at <a href="http://httpwg.github.io/">http://httpwg.github.io/</a>; source code and issues list for this draft can be found at <a href="https://github.com/httpwg/http-extensions/labels/secondary-certs">https://github.com/httpwg/http-extensions/labels/secondary-certs</a>.</p></div></section><section id="rfc.status"><h2><a href="#rfc.status">Status of this Memo</a></h2><div id="rfc.boilerplate.1.p.1"><p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p></div><div id="rfc.boilerplate.1.p.2"><p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF). Note that other groups may also distribute working documents as Internet-Drafts. The list of current Internet-Drafts is at <a href="http://datatracker.ietf.org/drafts/current/">http://datatracker.ietf.org/drafts/current/</a>.</p></div><div id="rfc.boilerplate.1.p.3"><p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time. It is inappropriate to use Internet-Drafts as reference material or to cite them other than as “work in progress”.</p></div><div id="rfc.boilerplate.1.p.4"><p>This Internet-Draft will expire on January 6, 2020.</p></div></section><section id="rfc.copyrightnotice"><h2><a href="#rfc.copyrightnotice">Copyright Notice</a></h2><div id="rfc.boilerplate.2.p.1"><p>Copyright © 2019 IETF Trust and the persons identified as the document authors. All rights reserved.</p></div><div id="rfc.boilerplate.2.p.2"><p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p></div></section><hr class="noprint"><nav id="rfc.toc"><h2 class="np"><a href="#rfc.toc">Table of Contents</a></h2><ul class="toc"><li><a href="#rfc.section.1">1.</a>   <a href="#introduction">Introduction</a><ul><li><a href="#rfc.section.1.1">1.1.</a>   <a href="#server-certificate-authentication">Server Certificate Authentication</a></li><li><a href="#rfc.section.1.2">1.2.</a>   <a href="#client-certificate-authentication">Client Certificate Authentication</a><ul><li><a href="#rfc.section.1.2.1">1.2.1.</a>   <a href="#http11-using-tls-12-and-earlier">HTTP/1.1 Using TLS 1.2 and Earlier</a></li><li><a href="#rfc.section.1.2.2">1.2.2.</a>   <a href="#http11-using-tls-13">HTTP/1.1 Using TLS 1.3</a></li><li><a href="#rfc.section.1.2.3">1.2.3.</a>   <a href="#http2">HTTP/2</a></li></ul></li><li><a href="#rfc.section.1.3">1.3.</a>   <a href="#http-layer-certificate-authentication">HTTP-Layer Certificate Authentication</a></li><li><a href="#rfc.section.1.4">1.4.</a>   <a href="#terminology">Terminology</a></li></ul></li><li><a href="#rfc.section.2">2.</a>   <a href="#discovery">Discovering Additional Certificates at the HTTP/2 Layer</a><ul><li><a href="#rfc.section.2.1">2.1.</a>   <a href="#setting">Indicating Support for HTTP-Layer Certificate Authentication</a></li><li><a href="#rfc.section.2.2">2.2.</a>   <a href="#cert-available">Making Certificates or Requests Available</a></li><li><a href="#rfc.section.2.3">2.3.</a>   <a href="#cert-challenge">Requiring Certificate Authentication</a><ul><li><a href="#rfc.section.2.3.1">2.3.1.</a>   <a href="#requiring-additional-server-certificates">Requiring Additional Server Certificates</a></li><li><a href="#rfc.section.2.3.2">2.3.2.</a>   <a href="#requiring-additional-client-certificates">Requiring Additional Client Certificates</a></li></ul></li></ul></li><li><a href="#rfc.section.3">3.</a>   <a href="#certs-http2">Certificates Frames for HTTP/2</a><ul><li><a href="#rfc.section.3.1">3.1.</a>   <a href="#http-cert-needed">The CERTIFICATE_NEEDED Frame</a></li><li><a href="#rfc.section.3.2">3.2.</a>   <a href="#http-use-certificate">The USE_CERTIFICATE Frame</a></li><li><a href="#rfc.section.3.3">3.3.</a>   <a href="#http-cert-request">The CERTIFICATE_REQUEST Frame</a><ul><li><a href="#rfc.section.3.3.1">3.3.1.</a>   <a href="#exp-req">Exported Authenticator Request Characteristics</a></li></ul></li><li><a href="#rfc.section.3.4">3.4.</a>   <a href="#http-cert">The CERTIFICATE Frame</a><ul><li><a href="#rfc.section.3.4.1">3.4.1.</a>   <a href="#exp-auth">Exported Authenticator Characteristics</a></li></ul></li></ul></li><li><a href="#rfc.section.4">4.</a>   <a href="#errors">Indicating Failures During HTTP-Layer Certificate Authentication</a></li><li><a href="#rfc.section.5">5.</a>   <a href="#extension">Required Domain Certificate Extension</a></li><li><a href="#rfc.section.6">6.</a>   <a href="#security">Security Considerations</a><ul><li><a href="#rfc.section.6.1">6.1.</a>   <a href="#impersonation">Impersonation</a></li><li><a href="#rfc.section.6.2">6.2.</a>   <a href="#fingerprinting">Fingerprinting</a></li><li><a href="#rfc.section.6.3">6.3.</a>   <a href="#denial-of-service">Denial of Service</a></li><li><a href="#rfc.section.6.4">6.4.</a>   <a href="#persistence-of-service">Persistence of Service</a></li><li><a href="#rfc.section.6.5">6.5.</a>   <a href="#confusion-about-state">Confusion About State</a></li></ul></li><li><a href="#rfc.section.7">7.</a>   <a href="#iana">IANA Considerations</a><ul><li><a href="#rfc.section.7.1">7.1.</a>   <a href="#iana-setting">HTTP/2 SETTINGS_HTTP_CERT_AUTH Setting</a></li><li><a href="#rfc.section.7.2">7.2.</a>   <a href="#iana-frame">New HTTP/2 Frames</a></li><li><a href="#rfc.section.7.3">7.3.</a>   <a href="#iana-errors">New HTTP/2 Error Codes</a></li></ul></li><li><a href="#rfc.section.8">8.</a>   <a href="#rfc.references">References</a><ul><li><a href="#rfc.section.8.1">8.1.</a>   <a href="#rfc.references.1">Normative References</a></li><li><a href="#rfc.section.8.2">8.2.</a>   <a href="#rfc.references.2">Informative References</a></li></ul></li><li><a href="#rfc.section.A">Appendix A.</a>   <a href="#change-log">Change Log</a><ul><li><a href="#rfc.section.A.1">A.1.</a>   <a href="#since-draft-ietf-httpbis-http2-secondary-certs-03">Since draft-ietf-httpbis-http2-secondary-certs-03:</a></li><li><a href="#rfc.section.A.2">A.2.</a>   <a href="#since-draft-ietf-httpbis-http2-secondary-certs-02">Since draft-ietf-httpbis-http2-secondary-certs-02:</a></li><li><a href="#rfc.section.A.3">A.3.</a>   <a href="#since-draft-ietf-httpbis-http2-secondary-certs-01">Since draft-ietf-httpbis-http2-secondary-certs-01:</a></li><li><a href="#rfc.section.A.4">A.4.</a>   <a href="#since-draft-ietf-httpbis-http2-secondary-certs-00">Since draft-ietf-httpbis-http2-secondary-certs-00:</a></li><li><a href="#rfc.section.A.5">A.5.</a>   <a href="#since-draft-bishop-httpbis-http2-additional-certs-05">Since draft-bishop-httpbis-http2-additional-certs-05:</a></li></ul></li><li><a href="#ack">Acknowledgements</a></li><li><a href="#rfc.authors">Authors' Addresses</a></li></ul><ul class="toc"><li>Figures<ul><li><a href="#rfc.figure.1">Figure 1: HTTP/1.1 reactive certificate authentication with TLS 1.2</a></li><li><a href="#rfc.figure.2">Figure 2: HTTP/1.1 reactive certificate authentication with TLS 1.3</a></li><li><a href="#rfc.figure.3">Figure 3: Proactive server authentication</a></li><li><a href="#rfc.figure.4">Figure 4: Proactive client authentication</a></li><li><a href="#rfc.figure.5">Figure 5: Client-requested certificate</a></li><li><a href="#rfc.figure.6">Figure 6: Reactive certificate authentication</a></li><li><a href="#rfc.figure.7">Figure 7: Frame correlation</a></li><li><a href="#rfc.figure.8">Figure 8: CERTIFICATE_NEEDED frame payload</a></li><li><a href="#rfc.figure.9">Figure 9: USE_CERTIFICATE frame payload</a></li><li><a href="#rfc.figure.10">Figure 10: CERTIFICATE_REQUEST frame payload</a></li><li><a href="#rfc.figure.11">Figure 11: CERTIFICATE frame payload</a></li></ul></li></ul></nav><hr class="noprint"><section id="introduction"><h2 id="rfc.section.1" class="np"><a href="#rfc.section.1">1.</a> <a href="#introduction">Introduction</a></h2><div id="rfc.section.1.p.1"><p>HTTP clients need to know that the content they receive on a connection comes from the origin that they intended to retrieve it from. The traditional form of server authentication in HTTP has been in the form of a single X.509 certificate provided during the TLS (<a href="#RFC5246"><cite title="The Transport Layer Security (TLS) Protocol Version 1.2">[RFC5246]</cite></a>, <a href="#RFC8446"><cite title="The Transport Layer Security (TLS) Protocol Version 1.3">[RFC8446]</cite></a>) handshake.</p></div><div id="rfc.section.1.p.2"><p>Many existing HTTP <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a> servers also have authentication requirements for the resources they serve. Of the bountiful authentication options available for authenticating HTTP requests, client certificates present a unique challenge for resource-specific authentication requirements because of the interaction with the underlying TLS layer.</p></div><div id="rfc.section.1.p.3"><p>TLS 1.2 <a href="#RFC5246"><cite title="The Transport Layer Security (TLS) Protocol Version 1.2">[RFC5246]</cite></a> supports one server and one client certificate on a connection. These certificates may contain multiple identities, but only one certificate may be provided.</p></div><div id="rfc.section.1.p.4"><p>Many HTTP servers host content from several origins. HTTP/2 permits clients to reuse an existing HTTP connection to a server provided that the secondary origin is also in the certificate provided during the TLS handshake. In many cases, servers choose to maintain separate certificates for different origins but still desire the benefits of a shared HTTP connection.</p></div><section id="server-certificate-authentication"><h3 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1.</a> <a href="#server-certificate-authentication">Server Certificate Authentication</a></h3><div id="rfc.section.1.1.p.1"><p>Section 9.1.1 of <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a> describes how connections may be used to make requests from multiple origins as long as the server is authoritative for both. A server is considered authoritative for an origin if DNS resolves the origin to the IP address of the server and (for TLS) if the certificate presented by the server contains the origin in the Subject Alternative Names field.</p></div><div id="rfc.section.1.1.p.2"><p><a href="#RFC7838"><cite title="HTTP Alternative Services">[RFC7838]</cite></a> enables a step of abstraction from the DNS resolution. If both hosts have provided an Alternative Service at hostnames which resolve to the IP address of the server, they are considered authoritative just as if DNS resolved the origin itself to that address. However, the server’s one TLS certificate is still required to contain the name of each origin in question.</p></div><div id="rfc.section.1.1.p.3"><p><a href="#RFC8336"><cite title="The ORIGIN HTTP/2 Frame">[RFC8336]</cite></a> relaxes the requirement to perform the DNS lookup if already connected to a server with an appropriate certificate which claims support for a particular origin.</p></div><div id="rfc.section.1.1.p.4"><p>Servers which host many origins often would prefer to have separate certificates for some sets of origins. This may be for ease of certificate management (the ability to separately revoke or renew them), due to different sources of certificates (a CDN acting on behalf of multiple origins), or other factors which might drive this administrative decision. Clients connecting to such origins cannot currently reuse connections, even if both client and server would prefer to do so.</p></div><div id="rfc.section.1.1.p.5"><p>Because the TLS SNI extension is exchanged in the clear, clients might also prefer to retrieve certificates inside the encrypted context. When this information is sensitive, it might be advantageous to request a general-purpose certificate or anonymous ciphersuite at the TLS layer, while acquiring the “real” certificate in HTTP after the connection is established.</p></div></section><section id="client-certificate-authentication"><h3 id="rfc.section.1.2"><a href="#rfc.section.1.2">1.2.</a> <a href="#client-certificate-authentication">Client Certificate Authentication</a></h3><div id="rfc.section.1.2.p.1"><p>For servers that wish to use client certificates to authenticate users, they might request client authentication during or immediately after the TLS handshake. However, if not all users or resources need certificate-based authentication, a request for a certificate has the unfortunate consequence of triggering the client to seek a certificate, possibly requiring user interaction, network traffic, or other time-consuming activities. During this time, the connection is stalled in many implementations. Such a request can result in a poor experience, particularly when sent to a client that does not expect the request.</p></div><div id="rfc.section.1.2.p.2"><p>The TLS 1.3 CertificateRequest can be used by servers to give clients hints about which certificate to offer. Servers that rely on certificate-based authentication might request different certificates for different resources. Such a server cannot use contextual information about the resource to construct an appropriate TLS CertificateRequest message during the initial handshake.</p></div><div id="rfc.section.1.2.p.3"><p>Consequently, client certificates are requested at connection establishment time only in cases where all clients are expected or required to have a single certificate that is used for all resources. Many other uses for client certificates are reactive, that is, certificates are requested in response to the client making a request.</p></div><section id="http11-using-tls-12-and-earlier"><h4 id="rfc.section.1.2.1"><a href="#rfc.section.1.2.1">1.2.1.</a> <a href="#http11-using-tls-12-and-earlier">HTTP/1.1 Using TLS 1.2 and Earlier</a></h4><div id="rfc.section.1.2.1.p.1"><p>In HTTP/1.1, a server that relies on client authentication for a subset of users or resources does not request a certificate when the connection is established. Instead, it only requests a client certificate when a request is made to a resource that requires a certificate. TLS 1.2 <a href="#RFC5246"><cite title="The Transport Layer Security (TLS) Protocol Version 1.2">[RFC5246]</cite></a> accommodates this by permitting the server to request a new TLS handshake, in which the server will request the client’s certificate.</p></div><div id="rfc.section.1.2.1.p.2"><p><a href="#ex-http11">Figure 1</a> shows the server initiating a TLS-layer renegotiation in response to receiving an HTTP/1.1 request to a protected resource.</p></div><div id="ex-http11"></div><div id="rfc.figure.1"><div><pre class="drawing">
Client                                      Server
   -- (HTTP) GET /protected -------------------&gt; *1
   &lt;---------------------- (TLS) HelloRequest -- *2
   -- (TLS) ClientHello -----------------------&gt;
   &lt;------------------ (TLS) ServerHello, ... --
   &lt;---------------- (TLS) CertificateRequest -- *3
   -- (TLS) ..., Certificate ------------------&gt; *4
   -- (TLS) Finished --------------------------&gt;
   &lt;-------------------------- (TLS) Finished --
   &lt;--------------------------- (HTTP) 200 OK -- *5
</pre></div></div><p class="figure">Figure 1: HTTP/1.1 reactive certificate authentication with TLS 1.2</p><div id="rfc.section.1.2.1.p.3"><p>In this example, the server receives a request for a protected resource (at *1 on <a href="#ex-http11">Figure 1</a>). Upon performing an authorization check, the server determines that the request requires authentication using a client certificate and that no such certificate has been provided.</p></div><div id="rfc.section.1.2.1.p.4"><p>The server initiates TLS renegotiation by sending a TLS HelloRequest (at *2). The client then initiates a TLS handshake. Note that some TLS messages are elided from the figure for the sake of brevity.</p></div><div id="rfc.section.1.2.1.p.5"><p>The critical messages for this example are the server requesting a certificate with a TLS CertificateRequest (*3); this request might use information about the request or resource. The client then provides a certificate and proof of possession of the private key in Certificate and CertificateVerify messages (*4).</p></div><div id="rfc.section.1.2.1.p.6"><p>When the handshake completes, the server performs any authorization checks a second time. With the client certificate available, it then authorizes the request and provides a response (*5).</p></div></section><section id="http11-using-tls-13"><h4 id="rfc.section.1.2.2"><a href="#rfc.section.1.2.2">1.2.2.</a> <a href="#http11-using-tls-13">HTTP/1.1 Using TLS 1.3</a></h4><div id="rfc.section.1.2.2.p.1"><p>TLS 1.3 <a href="#RFC8446"><cite title="The Transport Layer Security (TLS) Protocol Version 1.3">[RFC8446]</cite></a> introduces a new client authentication mechanism that allows for clients to authenticate after the handshake has been completed. For the purposes of authenticating an HTTP request, this is functionally equivalent to renegotiation. <a href="#ex-tls13">Figure 2</a> shows the simpler exchange this enables.</p></div><div id="ex-tls13"></div><div id="rfc.figure.2"><div><pre class="drawing">
Client                                      Server
   -- (HTTP) GET /protected -------------------&gt;
   &lt;---------------- (TLS) CertificateRequest --
   -- (TLS) Certificate, CertificateVerify,
               Finished -----------------------&gt;
   &lt;--------------------------- (HTTP) 200 OK --
</pre></div></div><p class="figure">Figure 2: HTTP/1.1 reactive certificate authentication with TLS 1.3</p><div id="rfc.section.1.2.2.p.2"><p>TLS 1.3 does not support renegotiation, instead supporting direct client authentication. In contrast to the TLS 1.2 example, in TLS 1.3, a server can simply request a certificate.</p></div></section><section id="http2"><h4 id="rfc.section.1.2.3"><a href="#rfc.section.1.2.3">1.2.3.</a> <a href="#http2">HTTP/2</a></h4><div id="rfc.section.1.2.3.p.1"><p>An important part of the HTTP/1.1 exchange is that the client is able to easily identify the request that caused the TLS renegotiation. The client is able to assume that the next unanswered request on the connection is responsible. The HTTP stack in the client is then able to direct the certificate request to the application or component that initiated that request. This ensures that the application has the right contextual information for processing the request.</p></div><div id="rfc.section.1.2.3.p.2"><p>In HTTP/2, a client can have multiple outstanding requests. Without some sort of correlation information, a client is unable to identify which request caused the server to request a certificate.</p></div><div id="rfc.section.1.2.3.p.3"><p>Thus, the minimum necessary mechanism to support reactive certificate authentication in HTTP/2 is an identifier that can be use to correlate an HTTP request with a request for a certificate. Since streams are used for individual requests, correlation with a stream is sufficient.</p></div><div id="rfc.section.1.2.3.p.4"><p><a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a> prohibits renegotiation after any application data has been sent. This completely blocks reactive certificate authentication in HTTP/2 using TLS 1.2. If this restriction were relaxed by an extension or update to HTTP/2, such an identifier could be added to TLS 1.2 by means of an extension to TLS. Unfortunately, many TLS 1.2 implementations do not permit application data to continue during a renegotiation. This is problematic for a multiplexed protocol like HTTP/2.</p></div></section></section><section id="http-layer-certificate-authentication"><h3 id="rfc.section.1.3"><a href="#rfc.section.1.3">1.3.</a> <a href="#http-layer-certificate-authentication">HTTP-Layer Certificate Authentication</a></h3><div id="rfc.section.1.3.p.1"><p>This draft defines HTTP/2 frames to carry the relevant certificate messages, enabling certificate-based authentication of both clients and servers independent of TLS version. This mechanism can be implemented at the HTTP layer without breaking the existing interface between HTTP and applications above it.</p></div><div id="rfc.section.1.3.p.2"><p>This could be done in a naive manner by replicating the TLS messages as HTTP/2 frames on each stream. However, this would create needless redundancy between streams and require frequent expensive signing operations. Instead, TLS Exported Authenticators <a href="#I-D.ietf-tls-exported-authenticator"><cite title="Exported Authenticators in TLS">[I-D.ietf-tls-exported-authenticator]</cite></a> are exchanged on stream zero and other frames incorporate them to particular requests by reference as needed.</p></div><div id="rfc.section.1.3.p.3"><p>TLS Exported Authenticators are structured messages that can be exported by either party of a TLS connection and validated by the other party. Given an established TLS connection, a request can be constructed which describes the desired certificate and an authenticator message can be constructed proving possession of a certificate and a corresponding private key. Both requests and authenticators can be generated by either the client or the server. Exported Authenticators use the message structures from Sections 4.3.2 and 4.4 of <a href="#RFC8446"><cite title="The Transport Layer Security (TLS) Protocol Version 1.3">[RFC8446]</cite></a>, but different parameters.</p></div><div id="rfc.section.1.3.p.4"><p>Each Authenticator is computed using a Handshake Context and Finished MAC Key derived from the TLS session. The Handshake Context is identical for both parties of the TLS connection, while the Finished MAC Key is dependent on whether the Authenticator is created by the client or the server.</p></div><div id="rfc.section.1.3.p.5"><p>Successfully verified Authenticators result in certificate chains, with verified possession of the corresponding private key, which can be supplied into a collection of available certificates. Likewise, descriptions of desired certificates can be supplied into these collections.</p></div><div id="rfc.section.1.3.p.6"><p><a href="#discovery" title="Discovering Additional Certificates at the HTTP/2 Layer">Section 2</a> describes how the feature is employed, defining means to detect support in peers (<a href="#setting" title="Indicating Support for HTTP-Layer Certificate Authentication">Section 2.1</a>), make certificates and requests available (<a href="#cert-available" title="Making Certificates or Requests Available">Section 2.2</a>), and indicate when streams are blocked waiting on an appropriate certificate (<a href="#cert-challenge" title="Requiring Certificate Authentication">Section 2.3</a>). <a href="#certs-http2" title="Certificates Frames for HTTP/2">Section 3</a> defines the required frame types, which parallel the TLS 1.3 message exchange. Finally, <a href="#errors" title="Indicating Failures During HTTP-Layer Certificate Authentication">Section 4</a> defines new error types which can be used to notify peers when the exchange has not been successful.</p></div></section><section id="terminology"><h3 id="rfc.section.1.4"><a href="#rfc.section.1.4">1.4.</a> <a href="#terminology">Terminology</a></h3><div id="rfc.section.1.4.p.1"><p>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in BCP 14 <a href="#RFC2119"><cite title="Key words for use in RFCs to Indicate Requirement Levels">[RFC2119]</cite></a> <a href="#RFC8174"><cite title="Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words">[RFC8174]</cite></a> when, and only when, they appear in all capitals, as shown here.</p></div></section></section><hr class="noprint"><section id="discovery"><h2 id="rfc.section.2" class="np"><a href="#rfc.section.2">2.</a> <a href="#discovery">Discovering Additional Certificates at the HTTP/2 Layer</a></h2><div id="rfc.section.2.p.1"><p>A certificate chain with proof of possession of the private key corresponding to the end-entity certificate is sent as a sequence of <span class="tt">CERTIFICATE</span> frames (see <a href="#http-cert" title="The CERTIFICATE Frame">Section 3.4</a>) on stream zero. Once the holder of a certificate has sent the chain and proof, this certificate chain is cached by the recipient and available for future use. Clients can proactively indicate the certificate they intend to use on each request using an unsolicited <span class="tt">USE_CERTIFICATE</span> frame, if desired. The previously-supplied certificates are available for reference without having to resend them.</p></div><div id="rfc.section.2.p.2"><p>Otherwise, the server uses a <span class="tt">CERTIFICATE_REQUEST</span> frame to describe a class of certificates on stream zero, then uses <span class="tt">CERTIFICATE_NEEDED</span> frames to associate these with individual requests. The client responds with a <span class="tt">USE_CERTIFICATE</span> frame indicating the certificate which should be used to satisfy the request.</p></div><div id="rfc.section.2.p.3"><p>Data sent by each peer is correlated by the ID given in each frame. This ID is unrelated to values used by the other peer, even if each uses the same ID in certain cases. <span class="tt">USE_CERTIFICATE</span> frames indicate whether they are sent proactively or are in response to a <span class="tt">CERTIFICATE_NEEDED</span> frame.</p></div><section id="setting"><h3 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1.</a> <a href="#setting">Indicating Support for HTTP-Layer Certificate Authentication</a></h3><div id="rfc.section.2.1.p.1"><p>Clients and servers that will accept requests for HTTP-layer certificate authentication indicate this using the HTTP/2 <span class="tt">SETTINGS_HTTP_CERT_AUTH</span> (0xSETTING-TBD) setting.</p></div><div id="rfc.section.2.1.p.2"><p>The initial value for the <span class="tt">SETTINGS_HTTP_CERT_AUTH</span> setting is 0, indicating that the peer does not support HTTP-layer certificate authentication. If a peer does support HTTP-layer certificate authentication, the value is non-zero.</p></div><div id="rfc.section.2.1.p.3"><p>In order to ensure that the TLS connection is direct to the server, rather than via a TLS-terminating proxy, each side will separately compute and confirm the value of this setting. The setting is derived from a TLS exporter (see Section 7.5 of <a href="#RFC8446"><cite title="The Transport Layer Security (TLS) Protocol Version 1.3">[RFC8446]</cite></a> and <a href="#RFC5705"><cite title="Keying Material Exporters for Transport Layer Security (TLS)">[RFC5705]</cite></a> for more details on exporters). Clients MUST NOT use an early exporter during their 0-RTT flight, but MUST send an updated SETTINGS frame using a regular exporter after the TLS handshake completes.</p></div><div id="rfc.section.2.1.p.4" class="avoidbreakafter"><p>The exporter is constructed with the following input:</p></div><div id="rfc.section.2.1.p.5"><ul><li>Label: <ul><li>“EXPORTER HTTP CERTIFICATE client” for clients</li><li>“EXPORTER HTTP CERTIFICATE server” for servers</li></ul></li><li>Context: Empty</li><li>Length: Four bytes</li></ul></div><div id="rfc.section.2.1.p.6" class="avoidbreakafter"><p>The resulting exporter is converted to a setting value as:</p></div><div id="rfc.figure.u.1"><div><pre>
(Exporter &amp; 0x3fffffff) | 0x80000000
</pre></div></div><div id="rfc.section.2.1.p.7"><p>That is, the most significant bit will always be set, regardless of the value of the exporter. Each endpoint will compute the expected value from their peer. If the setting is not received, or if the value received is not the expected value, the frames defined in this document SHOULD NOT be sent.</p></div></section><section id="cert-available"><h3 id="rfc.section.2.2"><a href="#rfc.section.2.2">2.2.</a> <a href="#cert-available">Making Certificates or Requests Available</a></h3><div id="rfc.section.2.2.p.1"><p>When both peers have advertised support for HTTP-layer certificates as in <a href="#setting" title="Indicating Support for HTTP-Layer Certificate Authentication">Section 2.1</a>, either party can supply additional certificates into the connection at any time. This means that clients or servers which predict a certificate will be required could supply the certificate before being asked. These certificates are available for reference by future <span class="tt">USE_CERTIFICATE</span> frames.</p></div><div id="rfc.section.2.2.p.2"><p>Certificates supplied by servers can be considered by clients without further action by the server. A server SHOULD NOT send certificates which do not cover origins which it is prepared to service on the current connection, but MAY use the ORIGIN frame <a href="#RFC8336"><cite title="The ORIGIN HTTP/2 Frame">[RFC8336]</cite></a> to indicate that not all covered origins will be served.</p></div><div id="ex-http2-server-proactive"></div><div id="rfc.figure.3"><div><pre class="drawing">
Client                                      Server
   &lt;------------------ (stream 0) CERTIFICATE --
   ...
   -- (stream N) GET /from-new-origin ---------&gt;
   &lt;----------------------- (stream N) 200 OK --

</pre></div></div><p class="figure">Figure 3: Proactive server authentication</p><div id="ex-http2-client-proactive"></div><div id="rfc.figure.4"><div><pre class="drawing">
Client                                      Server
   -- (stream 0) CERTIFICATE ------------------&gt;
   -- (stream 0) USE_CERTIFICATE (S=1) --------&gt;
   -- (stream 0) USE_CERTIFICATE (S=3) --------&gt;
   -- (streams 1,3) GET /protected ------------&gt;
   &lt;-------------------- (streams 1,3) 200 OK --

</pre></div></div><p class="figure">Figure 4: Proactive client authentication</p><div id="rfc.section.2.2.p.3"><p>Likewise, either party can supply a <span class="tt">CERTIFICATE_REQUEST</span> that outlines parameters of a certificate they might request in the future. Upon receipt of a <span class="tt">CERTIFICATE_REQUEST</span>, endpoints SHOULD provide a corresponding certificate in anticipation of a request shortly being blocked. Clients MAY wait for a <span class="tt">CERTIFICATE_NEEDED</span> frame to assist in associating the certificate request with a particular HTTP transaction.</p></div></section><section id="cert-challenge"><h3 id="rfc.section.2.3"><a href="#rfc.section.2.3">2.3.</a> <a href="#cert-challenge">Requiring Certificate Authentication</a></h3><section id="requiring-additional-server-certificates"><h4 id="rfc.section.2.3.1"><a href="#rfc.section.2.3.1">2.3.1.</a> <a href="#requiring-additional-server-certificates">Requiring Additional Server Certificates</a></h4><div id="rfc.section.2.3.1.p.1"><p>As defined in <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>, when a client finds that an https:// origin (or Alternative Service <a href="#RFC7838"><cite title="HTTP Alternative Services">[RFC7838]</cite></a>) to which it needs to make a request has the same IP address as a server to which it is already connected, it MAY check whether the TLS certificate provided contains the new origin as well, and if so, reuse the connection.</p></div><div id="rfc.section.2.3.1.p.2"><p>If the TLS certificate does not contain the new origin, but the server has claimed support for that origin (with an ORIGIN frame, see <a href="#RFC8336"><cite title="The ORIGIN HTTP/2 Frame">[RFC8336]</cite></a>) and advertised support for HTTP-layer certificates (see <a href="#setting" title="Indicating Support for HTTP-Layer Certificate Authentication">Section 2.1</a>), the client MAY send a <span class="tt">CERTIFICATE_REQUEST</span> frame describing the desired origin. The client then sends a <span class="tt">CERTIFICATE_NEEDED</span> frame for stream zero referencing the request, indicating that the connection cannot be used for that origin until the certificate is provided.</p></div><div id="rfc.section.2.3.1.p.3"><p>If the server does not have the desired certificate, it MUST send an Empty Authenticator, as described in Section 5 of <a href="#I-D.ietf-tls-exported-authenticator"><cite title="Exported Authenticators in TLS">[I-D.ietf-tls-exported-authenticator]</cite></a>, in a <span class="tt">CERTIFICATE</span> frame in response to the request, followed by a <span class="tt">USE_CERTIFICATE</span> frame for stream zero which references the Empty Authenticator. In this case, or if the server has not advertised support for HTTP-layer certificates, the client MUST NOT send any requests for resources in that origin on the current connection.</p></div><div id="ex-http2-server-requested"></div><div id="rfc.figure.5"><div><pre class="drawing">
Client                                      Server
   &lt;----------------------- (stream 0) ORIGIN --
   -- (stream 0) CERTIFICATE_REQUEST ----------&gt;
   -- (stream 0) CERTIFICATE_NEEDED (S=0) -----&gt;
   &lt;------------------ (stream 0) CERTIFICATE --
   &lt;-------- (stream 0) USE_CERTIFICATE (S=0) --
   -- (stream N) GET /from-new-origin ---------&gt;
   &lt;----------------------- (stream N) 200 OK --
</pre></div></div><p class="figure">Figure 5: Client-requested certificate</p><div id="rfc.section.2.3.1.p.4"><p>If a client receives a <span class="tt">PUSH_PROMISE</span> referencing an origin for which it has not yet received the server’s certificate, this is a fatal connection error (see section 8.2 of <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>). To avoid this, servers MUST supply the associated certificates before pushing resources from a different origin.</p></div></section><section id="requiring-additional-client-certificates"><h4 id="rfc.section.2.3.2"><a href="#rfc.section.2.3.2">2.3.2.</a> <a href="#requiring-additional-client-certificates">Requiring Additional Client Certificates</a></h4><div id="rfc.section.2.3.2.p.1"><p>Likewise, the server sends a <span class="tt">CERTIFICATE_NEEDED</span> frame for each stream where certificate authentication is required. The client answers with a <span class="tt">USE_CERTIFICATE</span> frame indicating the certificate to use on that stream. If the request parameters or the responding certificate are not already available, they will need to be sent as described in <a href="#cert-available" title="Making Certificates or Requests Available">Section 2.2</a> as part of this exchange.</p></div><div id="ex-http2-client-requested"></div><div id="rfc.figure.6"><div><pre class="drawing">
Client                                      Server
   &lt;---------- (stream 0) CERTIFICATE_REQUEST --
   ...
   -- (stream N) GET /protected ---------------&gt;
   &lt;----- (stream 0) CERTIFICATE_NEEDED (S=N) --
   -- (stream 0) CERTIFICATE ------------------&gt;
   -- (stream 0) USE_CERTIFICATE (S=N) --------&gt;
   &lt;----------------------- (stream N) 200 OK --
</pre></div></div><p class="figure">Figure 6: Reactive certificate authentication</p><div id="rfc.section.2.3.2.p.2"><p>If the client does not have the desired certificate, it instead sends an Empty Authenticator, as described in Section 5 of <a href="#I-D.ietf-tls-exported-authenticator"><cite title="Exported Authenticators in TLS">[I-D.ietf-tls-exported-authenticator]</cite></a>, in a <span class="tt">CERTIFICATE</span> frame in response to the request, followed by a <span class="tt">USE_CERTIFICATE</span> frame which references the Empty Authenticator. In this case, or if the client has not advertised support for HTTP-layer certificates, the server processes the request based solely on the certificate provided during the TLS handshake, if any. This might result in an error response via HTTP, such as a status code 403 (Not Authorized).</p></div></section></section></section><hr class="noprint"><section id="certs-http2"><h2 id="rfc.section.3" class="np"><a href="#rfc.section.3">3.</a> <a href="#certs-http2">Certificates Frames for HTTP/2</a></h2><div id="rfc.section.3.p.1"><p>The <span class="tt">CERTIFICATE_REQUEST</span> and <span class="tt">CERTIFICATE_NEEDED</span> frames are correlated by their <span class="tt">Request-ID</span> field. Subsequent <span class="tt">CERTIFICATE_NEEDED</span> frames with the same <span class="tt">Request-ID</span> value MAY be sent for other streams where the sender is expecting a certificate with the same parameters.</p></div><div id="rfc.section.3.p.2"><p>The <span class="tt">CERTIFICATE</span>, and <span class="tt">USE_CERTIFICATE</span> frames are correlated by their <span class="tt">Cert-ID</span> field. Subsequent <span class="tt">USE_CERTIFICATE</span> frames with the same <span class="tt">Cert-ID</span> MAY be sent in response to other <span class="tt">CERTIFICATE_NEEDED</span> frames and refer to the same certificate.</p></div><div id="rfc.section.3.p.3"><p><span class="tt">CERTIFICATE_NEEDED</span> and <span class="tt">USE_CERTIFICATE</span> frames are correlated by the Stream ID they reference. Unsolicited <span class="tt">USE_CERTIFICATE</span> frames are not responses to <span class="tt">CERTIFICATE_NEEDED</span> frames; otherwise, each <span class="tt">USE_CERTIFICATE</span> frame for a stream is considered to respond to a <span class="tt">CERTIFICATE_NEEDED</span> frame for the same stream in sequence.</p></div><div id="frame-relationships"></div><div id="rfc.figure.7"><div><pre class="drawing">
   +---------+           +---------+
   | REQUEST |           |   CERT  |
   +---------+           +---------+
        |                     |
        | Request-ID          | Cert-ID
        |                     |
        v                     v
   +---------+ Stream ID +---------+
   | NEEDED  |----------&gt;|   USE   |
   +---------+           +---------+
</pre></div></div><p class="figure">Figure 7: Frame correlation</p><div id="rfc.section.3.p.4"><p><span class="tt">Request-ID</span> and <span class="tt">Cert-ID</span> are independent and sender-local. The use of the same value by the other peer or in the other context does not imply any correlation between these frames. These values MUST be unique per sender for each space over the lifetime of the connection.</p></div><section id="http-cert-needed"><h3 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1.</a> <a href="#http-cert-needed">The CERTIFICATE_NEEDED Frame</a></h3><div id="rfc.section.3.1.p.1"><p>The <span class="tt">CERTIFICATE_NEEDED</span> frame (0xFRAME-TBD1) is sent on stream zero to indicate that the HTTP request on the indicated stream is blocked pending certificate authentication. The frame includes stream ID and a request identifier which can be used to correlate the stream with a previous <span class="tt">CERTIFICATE_REQUEST</span> frame sent on stream zero. The <span class="tt">CERTIFICATE_REQUEST</span> describes the certificate the sender requires to make progress on the stream in question.</p></div><div id="fig-cert-needed"></div><div id="rfc.figure.8"><div><pre class="drawing">
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +---------------------------------------------------------------+
 |R|                        Stream ID (31)                       |
 +-------------------------------+-------------------------------+
 |        Request-ID (16)        |
 +-------------------------------+
</pre></div></div><p class="figure">Figure 8: CERTIFICATE_NEEDED frame payload</p><div id="rfc.section.3.1.p.2"><p>The <span class="tt">CERTIFICATE_NEEDED</span> frame contains 6 octets. The first four octets indicate the Stream ID of the affected stream. The following two octets are the authentication request identifier, <span class="tt">Request-ID</span>. A peer that receives a <span class="tt">CERTIFICATE_NEEDED</span> of any other length MUST treat this as a stream error of type <span class="tt">PROTOCOL_ERROR</span>. Frames with identical request identifiers refer to the same <span class="tt">CERTIFICATE_REQUEST</span>.</p></div><div id="rfc.section.3.1.p.3"><p>A server MAY send multiple <span class="tt">CERTIFICATE_NEEDED</span> frames for the same stream. If a server requires that a client provide multiple certificates before authorizing a single request, each required certificate MUST be indicated with a separate <span class="tt">CERTIFICATE_NEEDED</span> frame, each of which MUST have a different request identifier (referencing different <span class="tt">CERTIFICATE_REQUEST</span> frames describing each required certificate). To reduce the risk of client confusion, servers SHOULD NOT have multiple outstanding <span class="tt">CERTIFICATE_NEEDED</span> frames for the same stream at any given time.</p></div><div id="rfc.section.3.1.p.4"><p>Clients MUST only send multiple <span class="tt">CERTIFICATE_NEEDED</span> frames for stream zero. Multiple <span class="tt">CERTIFICATE_NEEDED</span> frames on any other stream MUST be considered a stream error of type <span class="tt">PROTOCOL_ERROR</span>.</p></div><div id="rfc.section.3.1.p.5"><p>The <span class="tt">CERTIFICATE_NEEDED</span> frame MUST NOT be sent to a peer which has not advertised support for HTTP-layer certificate authentication.</p></div><div id="rfc.section.3.1.p.6"><p>The <span class="tt">CERTIFICATE_NEEDED</span> frame MUST NOT reference a stream in the “half-closed (local)” or “closed” states <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>. A client that receives a <span class="tt">CERTIFICATE_NEEDED</span> frame for a stream which is not in a valid state SHOULD treat this as a stream error of type <span class="tt">PROTOCOL_ERROR</span>.</p></div></section><section id="http-use-certificate"><h3 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2.</a> <a href="#http-use-certificate">The USE_CERTIFICATE Frame</a></h3><div id="rfc.section.3.2.p.1"><p>The <span class="tt">USE_CERTIFICATE</span> frame (0xFRAME-TBD4) is sent on stream zero to indicate which certificate is being used on a particular request stream.</p></div><div id="rfc.section.3.2.p.2" class="avoidbreakafter"><p>The <span class="tt">USE_CERTIFICATE</span> frame defines a single flag:</p></div><div id="rfc.section.3.2.p.3"><dl><dt>UNSOLICITED (0x01):</dt><dd>Indicates that no <span class="tt">CERTIFICATE_NEEDED</span> frame has yet been received for this stream.</dd></dl></div><div id="rfc.section.3.2.p.4" class="avoidbreakafter"><p>The payload of the <span class="tt">USE_CERTIFICATE</span> frame is as follows:</p></div><div id="fig-use-cert"></div><div id="rfc.figure.9"><div><pre class="drawing">
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +---------------------------------------------------------------+
 |R|                        Stream ID (31)                       |
 +-------------------------------+-------------------------------+
 |         [Cert-ID (16)]        |
 +-------------------------------+
</pre></div></div><p class="figure">Figure 9: USE_CERTIFICATE frame payload</p><div id="rfc.section.3.2.p.5"><p>The first four octets indicate the Stream ID of the affected stream. The following two octets, if present, contain the two-octet <span class="tt">Cert-ID</span> of the certificate the sender wishes to use. This MUST be the ID of a certificate for which proof of possession has been presented in a <span class="tt">CERTIFICATE</span> frame. Recipients of a <span class="tt">USE_CERTIFICATE</span> frame of any other length MUST treat this as a stream error of type <span class="tt">PROTOCOL_ERROR</span>. Frames with identical certificate identifiers refer to the same certificate chain.</p></div><div id="rfc.section.3.2.p.6"><p>A <span class="tt">USE_CERTIFICATE</span> frame which omits the Cert-ID refers to the certificate provided at the TLS layer, if any. If no certificate was provided at the TLS layer, the stream should be processed with no authentication, likely returning an authentication-related error at the HTTP level (e.g. 403) for servers or routing the request to a new connection for clients.</p></div><div id="rfc.section.3.2.p.7"><p>The <span class="tt">UNSOLICITED</span> flag MAY be set by clients on the first <span class="tt">USE_CERTIFICATE</span> frame referring to a given stream. This permits a client to proactively indicate which certificate should be used when processing a new request. When such an unsolicited indication refers to a request that has not yet been received, servers SHOULD cache the indication briefly in anticipation of the request.</p></div><div id="rfc.section.3.2.p.8"><p>Receipt of more than one unsolicited <span class="tt">USE_CERTIFICATE</span> frames or an unsolicited <span class="tt">USE_CERTIFICATE</span> frame which is not the first in reference to a given stream MUST be treated as a stream error of type <span class="tt">CERTIFICATE_OVERUSED</span>.</p></div><div id="rfc.section.3.2.p.9"><p>Each <span class="tt">USE_CERTIFICATE</span> frame which is not marked as unsolicited is considered to respond in order to the <span class="tt">CERTIFICATE_NEEDED</span> frames for the same stream. If a <span class="tt">USE_CERTIFICATE</span> frame is received for which a <span class="tt">CERTIFICATE_NEEDED</span> frame has not been sent, this MUST be treated as a stream error of type <span class="tt">CERTIFICATE_OVERUSED</span>.</p></div><div id="rfc.section.3.2.p.10"><p>Receipt of a <span class="tt">USE_CERTIFICATE</span> frame with an unknown <span class="tt">Cert-ID</span> MUST result in a stream error of type <span class="tt">PROTOCOL_ERROR</span>.</p></div><div id="rfc.section.3.2.p.11"><p>The referenced certificate chain needs to conform to the requirements expressed in the <span class="tt">CERTIFICATE_REQUEST</span> to the best of the sender’s ability, or the recipient is likely to reject it as unsuitable despite properly validating the authenticator. If the recipient considers the certificate unsuitable, it MAY at its discretion either return an error at the HTTP semantic layer, or respond with a stream error <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a> on any stream where the certificate is used. <a href="#errors" title="Indicating Failures During HTTP-Layer Certificate Authentication">Section 4</a> defines certificate-related error codes which might be applicable.</p></div></section><section id="http-cert-request"><h3 id="rfc.section.3.3"><a href="#rfc.section.3.3">3.3.</a> <a href="#http-cert-request">The CERTIFICATE_REQUEST Frame</a></h3><div id="rfc.section.3.3.p.1"><p>The <span class="tt">CERTIFICATE_REQUEST</span> frame (id=0xFRAME-TBD2) provides an exported authenticator request message from the TLS layer that specifies a desired certificate. This describes the certificate the sender wishes to have presented.</p></div><div id="rfc.section.3.3.p.2"><p>The <span class="tt">CERTIFICATE_REQUEST</span> frame SHOULD NOT be sent to a peer which has not advertised support for HTTP-layer certificate authentication.</p></div><div id="rfc.section.3.3.p.3"><p>The <span class="tt">CERTIFICATE_REQUEST</span> frame MUST be sent on stream zero. A <span class="tt">CERTIFICATE_REQUEST</span> frame received on any other stream MUST be rejected with a stream error of type <span class="tt">PROTOCOL_ERROR</span>.</p></div><div id="fig-cert-request"></div><div id="rfc.figure.10"><div><pre class="drawing">
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-------------------------------+-------------------------------+
 |        Request-ID (16)        |          Request (?)        ...
 +---------------------------------------------------------------+
</pre></div></div><p class="figure">Figure 10: CERTIFICATE_REQUEST frame payload</p><div id="rfc.section.3.3.p.4" class="avoidbreakafter"><p>The frame contains the following fields:</p></div><div id="rfc.section.3.3.p.5"><dl><dt>Request-ID:</dt><dd><span class="tt">Request-ID</span> is a 16-bit opaque identifier used to correlate subsequent certificate-related frames with this request. The identifier MUST be unique in the session for the sender.</dd><dt>Request:</dt><dd>An exported authenticator request, generated using the <span class="tt">request</span> API described in <a href="#I-D.ietf-tls-exported-authenticator"><cite title="Exported Authenticators in TLS">[I-D.ietf-tls-exported-authenticator]</cite></a>. See <a href="#exp-auth" title="Exported Authenticator Characteristics">Section 3.4.1</a> for more details on the input to this API.</dd></dl></div><section id="exp-req"><h4 id="rfc.section.3.3.1"><a href="#rfc.section.3.3.1">3.3.1.</a> <a href="#exp-req">Exported Authenticator Request Characteristics</a></h4><div id="rfc.section.3.3.1.p.1"><p>The Exported Authenticator <span class="tt">request</span> API defined in <a href="#I-D.ietf-tls-exported-authenticator"><cite title="Exported Authenticators in TLS">[I-D.ietf-tls-exported-authenticator]</cite></a> takes as input a set of desired certificate characteristics and a <span class="tt">certificate_request_context</span>, which needs to be unpredictable. When generating exported authenticators for use with this extension, the <span class="tt">certificate_request_context</span> MUST contain both the two-octet Request-ID as well as at least 96 bits of additional entropy.</p></div><div id="rfc.section.3.3.1.p.2"><p>Upon receipt of a <span class="tt">CERTIFICATE_REQUEST</span> frame, the recipient MUST verify that the first two octets of the authenticator’s <span class="tt">certificate_request_context</span> matches the Request-ID presented in the frame.</p></div><div id="rfc.section.3.3.1.p.3"><p>The TLS library on the authenticating peer will provide mechanisms to select an appropriate certificate to respond to the transported request. TLS libraries on servers MUST be able to recognize the <span class="tt">server_name</span> extension (<a href="#RFC6066"><cite title="Transport Layer Security (TLS) Extensions: Extension Definitions">[RFC6066]</cite></a>) at a minimum. Clients MUST always specify the desired origin using this extension, though other extensions MAY also be included.</p></div></section></section><section id="http-cert"><h3 id="rfc.section.3.4"><a href="#rfc.section.3.4">3.4.</a> <a href="#http-cert">The CERTIFICATE Frame</a></h3><div id="rfc.section.3.4.p.1"><p>The <span class="tt">CERTIFICATE</span> frame (id=0xFRAME-TBD3) provides an exported authenticator message from the TLS layer that provides a chain of certificates, associated extensions and proves possession of the private key corresponding to the end-entity certificate.</p></div><div id="rfc.section.3.4.p.2" class="avoidbreakafter"><p>The <span class="tt">CERTIFICATE</span> frame defines two flags:</p></div><div id="rfc.section.3.4.p.3"><dl><dt>TO_BE_CONTINUED (0x01):</dt><dd>Indicates that the exported authenticator spans more than one frame.</dd><dt>UNSOLICITED (0x02):</dt><dd>Indicates that the exported authenticator does not contain a Request-ID.</dd></dl></div><div id="fig-proof-frame"></div><div id="rfc.figure.11"><div><pre class="drawing">
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-------------------------------+-------------------------------+
 |          Cert-ID (16)         |        Request-ID (16)        |
 +-------------------------------+-------------------------------+
 |                   Authenticator Fragment (*)                ...
 +---------------------------------------------------------------+
</pre></div></div><p class="figure">Figure 11: CERTIFICATE frame payload</p><div id="rfc.section.3.4.p.4" class="avoidbreakafter"><p>The frame contains the following fields:</p></div><div id="rfc.section.3.4.p.5"><dl><dt>Cert-ID:</dt><dd><span class="tt">Cert-ID</span> is a 16-bit opaque identifier used to correlate other certificate- related frames with this exported authenticator fragment.</dd><dt>Request-ID:</dt><dd><span class="tt">Request-ID</span> is an optional 16-bit opaque identifier used to correlate this exported authenticator with the request which triggered it, if any. This field is present only if the <span class="tt">UNSOLICITED</span> flag is not set.</dd><dt>Authenticator Fragment:</dt><dd>A portion of the opaque data returned from the TLS connection exported authenticator <span class="tt">authenticate</span> API. See <a href="#exp-auth" title="Exported Authenticator Characteristics">Section 3.4.1</a> for more details on the input to this API.</dd></dl></div><div id="rfc.section.3.4.p.6"><p>An exported authenticator is transported in zero or more <span class="tt">CERTIFICATE</span> frames with the <span class="tt">TO_BE_CONTINUED</span> flag set, followed by one <span class="tt">CERTIFICATE</span> frame with the <span class="tt">TO_BE_CONTINUED</span> flag unset. Each of these frames contains the same <span class="tt">Cert-ID</span> field, permitting them to be associated with each other. Receipt of any <span class="tt">CERTIFICATE</span> frame with the same <span class="tt">Cert-ID</span> following the receipt of a <span class="tt">CERTIFICATE</span> frame with <span class="tt">TO_BE_CONTINUED</span> unset MUST be treated as a connection error of type <span class="tt">PROTOCOL_ERROR</span>.</p></div><div id="rfc.section.3.4.p.7"><p>If the <span class="tt">UNSOLICITED</span> flag is not set, the <span class="tt">CERTIFICATE</span> frame also contains a Request-ID indicating the certificate request which caused this exported authenticator to be generated. The value of this flag and the contents of the Request-ID field MUST NOT differ between frames with the same Cert-ID.</p></div><div id="rfc.section.3.4.p.8"><p>Upon receiving a complete series of <span class="tt">CERTIFICATE</span> frames, the receiver may validate the Exported Authenticator value by using the exported authenticator API. This returns either an error indicating that the message was invalid, or the certificate chain and extensions used to create the message.</p></div><div id="rfc.section.3.4.p.9"><p>The <span class="tt">CERTIFICATE</span> frame MUST be sent on stream zero. A <span class="tt">CERTIFICATE</span> frame received on any other stream MUST be rejected with a stream error of type <span class="tt">PROTOCOL_ERROR</span>.</p></div><section id="exp-auth"><h4 id="rfc.section.3.4.1"><a href="#rfc.section.3.4.1">3.4.1.</a> <a href="#exp-auth">Exported Authenticator Characteristics</a></h4><div id="rfc.section.3.4.1.p.1"><p>The Exported Authenticator API defined in <a href="#I-D.ietf-tls-exported-authenticator"><cite title="Exported Authenticators in TLS">[I-D.ietf-tls-exported-authenticator]</cite></a> takes as input a request, a set of certificates, and supporting information about the certificate (OCSP, SCT, etc.). The result is an opaque token which is used when generating the <span class="tt">CERTIFICATE</span> frame.</p></div><div id="rfc.section.3.4.1.p.2" class="avoidbreakafter"><p>Upon receipt of a <span class="tt">CERTIFICATE</span> frame, an endpoint MUST perform the following steps to validate the token it contains:</p></div><div id="rfc.section.3.4.1.p.3"><ul><li>Verify that either the <span class="tt">UNSOLICITED</span> flag is set (clients only) or that the Request-ID field contains the Request-ID of a previously-sent <span class="tt">CERTIFICATE_REQUEST</span> frame.</li><li>Using the <span class="tt">get context</span> API, retrieve the <span class="tt">certificate_request_context</span> used to generate the authenticator, if any. Verify that the <span class="tt">certificate_request_context</span> begins with the supplied Request-ID, if any.</li><li>Use the <span class="tt">validate</span> API to confirm the validity of the authenticator with regard to the generated request (if any).</li></ul></div><div id="rfc.section.3.4.1.p.4"><p>Once the authenticator is accepted, the endpoint can perform any other checks for the acceptability of the certificate itself. Clients MUST NOT accept any end-entity certificate from an exported authenticator which does not contain the Required Domain extension; see <a href="#extension" title="Required Domain Certificate Extension">Section 5</a> and <a href="#impersonation" title="Impersonation">Section 6.1</a>.</p></div></section></section></section><hr class="noprint"><section id="errors"><h2 id="rfc.section.4" class="np"><a href="#rfc.section.4">4.</a> <a href="#errors">Indicating Failures During HTTP-Layer Certificate Authentication</a></h2><div id="rfc.section.4.p.1"><p>Because this draft permits certificates to be exchanged at the HTTP framing layer instead of the TLS layer, several certificate-related errors which are defined at the TLS layer might now occur at the HTTP framing layer. In this section, those errors are restated and added to the HTTP/2 error code registry.</p></div><div id="rfc.section.4.p.2"><dl><dt>BAD_CERTIFICATE (0xERROR-TBD1):</dt><dd>A certificate was corrupt, contained signatures that did not verify correctly, etc.</dd><dt>UNSUPPORTED_CERTIFICATE (0xERROR-TBD2):</dt><dd>A certificate was of an unsupported type or did not contain required extensions</dd><dt>CERTIFICATE_REVOKED (0xERROR-TBD3):</dt><dd>A certificate was revoked by its signer</dd><dt>CERTIFICATE_EXPIRED (0xERROR-TBD4):</dt><dd>A certificate has expired or is not currently valid</dd><dt>CERTIFICATE_GENERAL (0xERROR-TBD5):</dt><dd>Any other certificate-related error</dd><dt>CERTIFICATE_OVERUSED (0xERROR-TBD6):</dt><dd>More certificates were used on a request than were requested</dd></dl></div><div id="rfc.section.4.p.3"><p>As described in <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>, implementations MAY choose to treat a stream error as a connection error at any time. Of particular note, a stream error cannot occur on stream 0, which means that implementations cannot send non-session errors in response to <span class="tt">CERTIFICATE_REQUEST</span>, and <span class="tt">CERTIFICATE</span> frames. Implementations which do not wish to terminate the connection MAY either send relevant errors on any stream which references the failing certificate in question or process the requests as unauthenticated and provide error information at the HTTP semantic layer.</p></div></section><hr class="noprint"><section id="extension"><h2 id="rfc.section.5" class="np"><a href="#rfc.section.5">5.</a> <a href="#extension">Required Domain Certificate Extension</a></h2><div id="rfc.section.5.p.1"><p>The Required Domain extension allows certificates to limit their use with Secondary Certificate Authentication. A client MUST verify that the server has proven ownership of the indicated identity before accepting the limited certificate over Secondary Certificate Authentication.</p></div><div id="rfc.section.5.p.2"><p>The identity in this extension is a restriction asserted by the requester of the certificate and is not verified by the CA. Conforming CAs SHOULD mark the requiredDomain extension as non-critical. Conforming CAs MUST require the presence of a CAA record <a href="#RFC6844"><cite title="DNS Certification Authority Authorization (CAA) Resource Record">[RFC6844]</cite></a> prior to issuing a certificate with this extension. Because a Required Domain value of “*” has a much higher risk of reuse if compromised, conforming Certificate Authorities are encouraged to require more extensive verification prior to issuing such a certificate.</p></div><div id="rfc.section.5.p.3"><p>The required domain is represented as a GeneralName, as specified in Section 4.2.1.6 of <a href="#RFC5280"><cite title="Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile">[RFC5280]</cite></a>. Unlike the subject field, conforming CAs MUST NOT issue certificates with a requiredDomain extension containing empty GeneralName fields. Clients that encounter such a certificate when processing a certification path MUST consider the certificate invalid.</p></div><div id="rfc.section.5.p.4"><p>The wildcard character “<em>” MAY be used to represent that any previously authenticated identity is acceptable. This character MUST be the entirety of the name if used and MUST have a type of “dNSName”. (That is, “</em>” is acceptable, but “<em>.com” and “w</em>.example.com” are not).</p></div><div id="rfc.figure.u.2"><div><pre>
id-ce-requiredDomain OBJECT IDENTIFIER ::=  { id-ce TBD1 }

RequiredDomain ::= GeneralName
</pre></div></div></section><hr class="noprint"><section id="security"><h2 id="rfc.section.6" class="np"><a href="#rfc.section.6">6.</a> <a href="#security">Security Considerations</a></h2><div id="rfc.section.6.p.1"><p>This mechanism defines an alternate way to obtain server and client certificates other than in the initial TLS handshake. While the signature of exported authenticator values is expected to be equally secure, it is important to recognize that a vulnerability in this code path is at least equal to a vulnerability in the TLS handshake.</p></div><section id="impersonation"><h3 id="rfc.section.6.1"><a href="#rfc.section.6.1">6.1.</a> <a href="#impersonation">Impersonation</a></h3><div id="rfc.section.6.1.p.1"><p>This mechanism could increase the impact of a key compromise. Rather than needing to subvert DNS or IP routing in order to use a compromised certificate, a malicious server now only needs a client to connect to <em>some</em> HTTPS site under its control in order to present the compromised certificate. As recommended in <a href="#RFC8336"><cite title="The ORIGIN HTTP/2 Frame">[RFC8336]</cite></a>, clients opting not to consult DNS ought to employ some alternative means to increase confidence that the certificate is legitimate.</p></div><div id="rfc.section.6.1.p.2"><p>One such means is the Required Domain certificate extension defined in {extension}. Clients MUST require that server certificates presented via this mechanism contain the Required Domain extension and require that a certificate previously accepted on the connection (including the certificate presented in TLS) lists the Required Domain in the Subject field or the Subject Alternative Name extension.</p></div><div id="rfc.section.6.1.p.3"><p>As noted in the Security Considerations of <a href="#I-D.ietf-tls-exported-authenticator"><cite title="Exported Authenticators in TLS">[I-D.ietf-tls-exported-authenticator]</cite></a>, it is difficult to formally prove that an endpoint is jointly authoritative over multiple certificates, rather than individually authoritative on each certificate. As a result, clients MUST NOT assume that because one origin was previously colocated with another, those origins will be reachable via the same endpoints in the future. Clients MUST NOT consider previous secondary certificates to be validated after TLS session resumption. However, clients MAY proactively query for previously-presented secondary certificates.</p></div></section><section id="fingerprinting"><h3 id="rfc.section.6.2"><a href="#rfc.section.6.2">6.2.</a> <a href="#fingerprinting">Fingerprinting</a></h3><div id="rfc.section.6.2.p.1"><p>This draft defines a mechanism which could be used to probe servers for origins they support, but opens no new attack versus making repeat TLS connections with different SNI values. Servers SHOULD impose similar denial-of-service mitigations (e.g. request rate limits) to <span class="tt">CERTIFICATE_REQUEST</span> frames as to new TLS connections.</p></div><div id="rfc.section.6.2.p.2"><p>While the extensions in the <span class="tt">CERTIFICATE_REQUEST</span> frame permit the sender to enumerate the acceptable Certificate Authorities for the requested certificate, it might not be prudent (either for security or data consumption) to include the full list of trusted Certificate Authorities in every request. Senders, particularly clients, SHOULD send only the extensions that narrowly specify which certificates would be acceptable.</p></div></section><section id="denial-of-service"><h3 id="rfc.section.6.3"><a href="#rfc.section.6.3">6.3.</a> <a href="#denial-of-service">Denial of Service</a></h3><div id="rfc.section.6.3.p.1"><p>Failure to provide a certificate on a stream after receiving <span class="tt">CERTIFICATE_NEEDED</span> blocks processing, and SHOULD be subject to standard timeouts used to guard against unresponsive peers.</p></div><div id="rfc.section.6.3.p.2"><p>Validating a multitude of signatures can be computationally expensive, while generating an invalid signature is computationally cheap. Implementations will require checks for attacks from this direction. Invalid exported authenticators SHOULD be treated as a session error, to avoid further attacks from the peer, though an implementation MAY instead disable HTTP-layer certificates for the current connection instead.</p></div></section><section id="persistence-of-service"><h3 id="rfc.section.6.4"><a href="#rfc.section.6.4">6.4.</a> <a href="#persistence-of-service">Persistence of Service</a></h3><div id="rfc.section.6.4.p.1"><p>CNAME records in the DNS are frequently used to delegate authority for an origin to a third-party provider. This delegation can be changed without notice, even to the third-party provider, simply by modifying the CNAME record in question.</p></div><div id="rfc.section.6.4.p.2"><p>After the owner of the domain has redirected traffic elsewhere by changing the CNAME, new connections will not arrive for that origin, but connections which are properly directed to this provider for other origins would continue to claim control of this origin (via ORIGIN frame and Secondary Certificates). This is proper behavior based on the third-party provider’s configuration, but would likely not be what is intended by the owner of the origin.</p></div><div id="rfc.section.6.4.p.3"><p>This is not an issue which can be mitigated by the protocol, but something about which third-party providers SHOULD educate their customers before using the features described in this document.</p></div></section><section id="confusion-about-state"><h3 id="rfc.section.6.5"><a href="#rfc.section.6.5">6.5.</a> <a href="#confusion-about-state">Confusion About State</a></h3><div id="rfc.section.6.5.p.1"><p>Implementations need to be aware of the potential for confusion about the state of a connection. The presence or absence of a validated certificate can change during the processing of a request, potentially multiple times, as <span class="tt">USE_CERTIFICATE</span> frames are received. A server that uses certificate authentication needs to be prepared to reevaluate the authorization state of a request as the set of certificates changes.</p></div><div id="rfc.section.6.5.p.2"><p>Client implementations need to carefully consider the impact of setting the <span class="tt">AUTOMATIC_USE</span> flag. This flag is a performance optimization, permitting the client to avoid a round-trip on each request where the server checks for certificate authentication. However, once this flag has been sent, the client has zero knowledge about whether the server will use the referenced cert for any future request, or even for an existing request which has not yet completed. Clients MUST NOT set this flag on any certificate which is not appropriate for currently-in-flight requests, and MUST NOT make any future requests on the same connection which they are not willing to have associated with the provided certificate.</p></div></section></section><hr class="noprint"><section id="iana"><h2 id="rfc.section.7" class="np"><a href="#rfc.section.7">7.</a> <a href="#iana">IANA Considerations</a></h2><div id="rfc.section.7.p.1"><p>This draft adds entries in three registries.</p></div><div id="rfc.section.7.p.2"><p>The HTTP/2 <span class="tt">SETTINGS_HTTP_CERT_AUTH</span> setting is registered in <a href="#iana-setting" title="HTTP/2 SETTINGS_HTTP_CERT_AUTH Setting">Section 7.1</a>. Four frame types are registered in <a href="#iana-frame" title="New HTTP/2 Frames">Section 7.2</a>. Six error codes are registered in <a href="#iana-errors" title="New HTTP/2 Error Codes">Section 7.3</a>.</p></div><section id="iana-setting"><h3 id="rfc.section.7.1"><a href="#rfc.section.7.1">7.1.</a> <a href="#iana-setting">HTTP/2 SETTINGS_HTTP_CERT_AUTH Setting</a></h3><div id="rfc.section.7.1.p.1"><p>The SETTINGS_HTTP_CERT_AUTH setting is registered in the “HTTP/2 Settings” registry established in <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>.</p></div><div id="rfc.section.7.1.p.2"><dl><dt>Name:</dt><dd>SETTINGS_HTTP_CERT_AUTH</dd><dt>Code:</dt><dd>0xSETTING-TBD</dd><dt>Initial Value:</dt><dd>0</dd><dt>Specification:</dt><dd>This document.</dd></dl></div></section><section id="iana-frame"><h3 id="rfc.section.7.2"><a href="#rfc.section.7.2">7.2.</a> <a href="#iana-frame">New HTTP/2 Frames</a></h3><div id="rfc.section.7.2.p.1"><p>Four new frame types are registered in the “HTTP/2 Frame Types” registry established in <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>. The entries in the following table are registered by this document.</p></div><div id="rfc.table.u.1" class="tt"><table class="tt full tcenter"><thead><tr><th class="left">Frame Type</th><th class="left">Code</th><th class="left">Specification</th></tr></thead><tbody><tr><td class="left">CERTIFICATE_NEEDED</td><td class="left">0xFRAME-TBD1</td><td class="left"><a href="#http-cert-needed" title="The CERTIFICATE_NEEDED Frame">Section 3.1</a></td></tr><tr><td class="left">CERTIFICATE_REQUEST</td><td class="left">0xFRAME-TBD2</td><td class="left"><a href="#http-cert-request" title="The CERTIFICATE_REQUEST Frame">Section 3.3</a></td></tr><tr><td class="left">CERTIFICATE</td><td class="left">0xFRAME-TBD3</td><td class="left"><a href="#http-cert" title="The CERTIFICATE Frame">Section 3.4</a></td></tr><tr><td class="left">USE_CERTIFICATE</td><td class="left">0xFRAME-TBD4</td><td class="left"><a href="#http-use-certificate" title="The USE_CERTIFICATE Frame">Section 3.2</a></td></tr></tbody></table></div></section><section id="iana-errors"><h3 id="rfc.section.7.3"><a href="#rfc.section.7.3">7.3.</a> <a href="#iana-errors">New HTTP/2 Error Codes</a></h3><div id="rfc.section.7.3.p.1"><p>Six new error codes are registered in the “HTTP/2 Error Code” registry established in <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>. The entries in the following table are registered by this document.</p></div><div id="rfc.table.u.2" class="tt"><table class="tt full tcenter"><thead><tr><th class="left">Name</th><th class="left">Code</th><th class="left">Specification</th></tr></thead><tbody><tr><td class="left">BAD_CERTIFICATE</td><td class="left">0xERROR-TBD1</td><td class="left"><a href="#errors" title="Indicating Failures During HTTP-Layer Certificate Authentication">Section 4</a></td></tr><tr><td class="left">UNSUPPORTED_CERTIFICATE</td><td class="left">0xERROR-TBD2</td><td class="left"><a href="#errors" title="Indicating Failures During HTTP-Layer Certificate Authentication">Section 4</a></td></tr><tr><td class="left">CERTIFICATE_REVOKED</td><td class="left">0xERROR-TBD3</td><td class="left"><a href="#errors" title="Indicating Failures During HTTP-Layer Certificate Authentication">Section 4</a></td></tr><tr><td class="left">CERTIFICATE_EXPIRED</td><td class="left">0xERROR-TBD4</td><td class="left"><a href="#errors" title="Indicating Failures During HTTP-Layer Certificate Authentication">Section 4</a></td></tr><tr><td class="left">CERTIFICATE_GENERAL</td><td class="left">0xERROR-TBD5</td><td class="left"><a href="#errors" title="Indicating Failures During HTTP-Layer Certificate Authentication">Section 4</a></td></tr><tr><td class="left">CERTIFICATE_OVERUSED</td><td class="left">0xERROR-TBD6</td><td class="left"><a href="#errors" title="Indicating Failures During HTTP-Layer Certificate Authentication">Section 4</a></td></tr></tbody></table></div></section></section><hr class="noprint"><section id="rfc.references" class="np"><h2 id="rfc.section.8"><a href="#rfc.section.8">8.</a> References</h2><section class="np"><div id="rfc.references.1"><h3 id="rfc.section.8.1"><a href="#rfc.section.8.1">8.1.</a> Normative References</h3><dl class="reference"><dt id="I-D.ietf-tls-exported-authenticator">[I-D.ietf-tls-exported-authenticator]</dt><dd>Sullivan, N., “<a href="https://tools.ietf.org/html/draft-ietf-tls-exported-authenticator-09">Exported Authenticators in TLS</a>”, Internet-Draft draft-ietf-tls-exported-authenticator-09 (<a href="https://datatracker.ietf.org/doc/draft-ietf-tls-exported-authenticator">work in progress</a>), May 2019.</dd><dt id="RFC2119">[RFC2119]</dt><dd>Bradner, S., “<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>”, BCP 14, RFC 2119, <a href="http://dx.doi.org/10.17487/RFC2119">DOI 10.17487/RFC2119</a>, March 1997, &lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;.</dd><dt id="RFC5246">[RFC5246]</dt><dd>Dierks, T. and E. Rescorla, “<a href="https://tools.ietf.org/html/rfc5246">The Transport Layer Security (TLS) Protocol Version 1.2</a>”, RFC 5246, <a href="http://dx.doi.org/10.17487/RFC5246">DOI 10.17487/RFC5246</a>, August 2008, &lt;<a href="https://www.rfc-editor.org/info/rfc5246">https://www.rfc-editor.org/info/rfc5246</a>&gt;.</dd><dt id="RFC5280">[RFC5280]</dt><dd>Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, “<a href="https://tools.ietf.org/html/rfc5280">Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</a>”, RFC 5280, <a href="http://dx.doi.org/10.17487/RFC5280">DOI 10.17487/RFC5280</a>, May 2008, &lt;<a href="https://www.rfc-editor.org/info/rfc5280">https://www.rfc-editor.org/info/rfc5280</a>&gt;.</dd><dt id="RFC6066">[RFC6066]</dt><dd>Eastlake 3rd, D., “<a href="https://tools.ietf.org/html/rfc6066">Transport Layer Security (TLS) Extensions: Extension Definitions</a>”, RFC 6066, <a href="http://dx.doi.org/10.17487/RFC6066">DOI 10.17487/RFC6066</a>, January 2011, &lt;<a href="https://www.rfc-editor.org/info/rfc6066">https://www.rfc-editor.org/info/rfc6066</a>&gt;.</dd><dt id="RFC6844">[RFC6844]</dt><dd>Hallam-Baker, P. and R. Stradling, “<a href="https://tools.ietf.org/html/rfc6844">DNS Certification Authority Authorization (CAA) Resource Record</a>”, RFC 6844, <a href="http://dx.doi.org/10.17487/RFC6844">DOI 10.17487/RFC6844</a>, January 2013, &lt;<a href="https://www.rfc-editor.org/info/rfc6844">https://www.rfc-editor.org/info/rfc6844</a>&gt;.</dd><dt id="RFC7230">[RFC7230]</dt><dd>Fielding, R., Ed. and J. Reschke, Ed., “<a href="https://tools.ietf.org/html/rfc7230">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a>”, RFC 7230, <a href="http://dx.doi.org/10.17487/RFC7230">DOI 10.17487/RFC7230</a>, June 2014, &lt;<a href="https://www.rfc-editor.org/info/rfc7230">https://www.rfc-editor.org/info/rfc7230</a>&gt;.</dd><dt id="RFC7540">[RFC7540]</dt><dd>Belshe, M., Peon, R., and M. Thomson, Ed., “<a href="https://tools.ietf.org/html/rfc7540">Hypertext Transfer Protocol Version 2 (HTTP/2)</a>”, RFC 7540, <a href="http://dx.doi.org/10.17487/RFC7540">DOI 10.17487/RFC7540</a>, May 2015, &lt;<a href="https://www.rfc-editor.org/info/rfc7540">https://www.rfc-editor.org/info/rfc7540</a>&gt;.</dd><dt id="RFC8174">[RFC8174]</dt><dd>Leiba, B., “<a href="https://tools.ietf.org/html/rfc8174">Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</a>”, BCP 14, RFC 8174, <a href="http://dx.doi.org/10.17487/RFC8174">DOI 10.17487/RFC8174</a>, May 2017, &lt;<a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>&gt;.</dd><dt id="RFC8446">[RFC8446]</dt><dd>Rescorla, E., “<a href="https://tools.ietf.org/html/rfc8446">The Transport Layer Security (TLS) Protocol Version 1.3</a>”, RFC 8446, <a href="http://dx.doi.org/10.17487/RFC8446">DOI 10.17487/RFC8446</a>, August 2018, &lt;<a href="https://www.rfc-editor.org/info/rfc8446">https://www.rfc-editor.org/info/rfc8446</a>&gt;.</dd></dl></div></section><section><div id="rfc.references.2"><h3 id="rfc.section.8.2"><a href="#rfc.section.8.2">8.2.</a> Informative References</h3><dl class="reference"><dt id="RFC5705">[RFC5705]</dt><dd>Rescorla, E., “<a href="https://tools.ietf.org/html/rfc5705">Keying Material Exporters for Transport Layer Security (TLS)</a>”, RFC 5705, <a href="http://dx.doi.org/10.17487/RFC5705">DOI 10.17487/RFC5705</a>, March 2010, &lt;<a href="https://www.rfc-editor.org/info/rfc5705">https://www.rfc-editor.org/info/rfc5705</a>&gt;.</dd><dt id="RFC7838">[RFC7838]</dt><dd>Nottingham, M., McManus, P., and J. Reschke, “<a href="https://tools.ietf.org/html/rfc7838">HTTP Alternative Services</a>”, RFC 7838, <a href="http://dx.doi.org/10.17487/RFC7838">DOI 10.17487/RFC7838</a>, April 2016, &lt;<a href="https://www.rfc-editor.org/info/rfc7838">https://www.rfc-editor.org/info/rfc7838</a>&gt;.</dd><dt id="RFC8336">[RFC8336]</dt><dd>Nottingham, M. and E. Nygren, “<a href="https://tools.ietf.org/html/rfc8336">The ORIGIN HTTP/2 Frame</a>”, RFC 8336, <a href="http://dx.doi.org/10.17487/RFC8336">DOI 10.17487/RFC8336</a>, March 2018, &lt;<a href="https://www.rfc-editor.org/info/rfc8336">https://www.rfc-editor.org/info/rfc8336</a>&gt;.</dd></dl></div></section></section><hr class="noprint"><section id="change-log"><h2 id="rfc.section.A" class="np"><a href="#rfc.section.A">Appendix A.</a> <a href="#change-log">Change Log</a></h2><div id="rfc.section.A.p.1"><ul class="empty"><li><strong>RFC Editor’s Note:</strong> Please remove this section prior to publication of a final version of this document.</li></ul></div><section id="since-draft-ietf-httpbis-http2-secondary-certs-03"><h3 id="rfc.section.A.1"><a href="#rfc.section.A.1">A.1.</a> <a href="#since-draft-ietf-httpbis-http2-secondary-certs-03">Since draft-ietf-httpbis-http2-secondary-certs-03:</a></h3><div id="rfc.section.A.1.p.1"><ul><li><span class="tt">CERTIFICATE_REQUEST</span> frames contain the Request-ID, which MUST be checked against the <span class="tt">certificate_request_context</span> of the Exported Authenticator Request</li><li><span class="tt">CERTIFICATE</span> frames contain the Request-ID to which they respond, unless the UNSOLICITED flag is set</li><li>The Required Domain extension is defined for certificates, which must be present for certificates presented by servers</li></ul></div></section><section id="since-draft-ietf-httpbis-http2-secondary-certs-02"><h3 id="rfc.section.A.2"><a href="#rfc.section.A.2">A.2.</a> <a href="#since-draft-ietf-httpbis-http2-secondary-certs-02">Since draft-ietf-httpbis-http2-secondary-certs-02:</a></h3><div id="rfc.section.A.2.p.1"><p>Editorial updates only.</p></div></section><section id="since-draft-ietf-httpbis-http2-secondary-certs-01"><h3 id="rfc.section.A.3"><a href="#rfc.section.A.3">A.3.</a> <a href="#since-draft-ietf-httpbis-http2-secondary-certs-01">Since draft-ietf-httpbis-http2-secondary-certs-01:</a></h3><div id="rfc.section.A.3.p.1"><ul><li>Clients can send <span class="tt">CERTIFICATE_NEEDED</span> for stream 0 rather than speculatively reserving a stream for an origin.</li><li>Use SETTINGS to disable when a TLS-terminating proxy is present (#617,#651)</li></ul></div></section><section id="since-draft-ietf-httpbis-http2-secondary-certs-00"><h3 id="rfc.section.A.4"><a href="#rfc.section.A.4">A.4.</a> <a href="#since-draft-ietf-httpbis-http2-secondary-certs-00">Since draft-ietf-httpbis-http2-secondary-certs-00:</a></h3><div id="rfc.section.A.4.p.1"><ul><li>All frames sent on stream zero; replaced <span class="tt">AUTOMATIC_USE</span> on <span class="tt">CERTIFICATE</span> with <span class="tt">UNSOLICITED</span> on <span class="tt">USE_CERTIFICATE</span>. (#482,#566)</li><li>Use Exported Requests from the TLS Exported Authenticators draft; eliminate facilities for expressing certificate requirements in <span class="tt">CERTIFICATE_REQUEST</span> frame. (#481)</li></ul></div></section><section id="since-draft-bishop-httpbis-http2-additional-certs-05"><h3 id="rfc.section.A.5"><a href="#rfc.section.A.5">A.5.</a> <a href="#since-draft-bishop-httpbis-http2-additional-certs-05">Since draft-bishop-httpbis-http2-additional-certs-05:</a></h3><div id="rfc.section.A.5.p.1"><ul><li>Adopted as draft-ietf-httpbis-http2-secondary-certs</li></ul></div></section></section><hr class="noprint"><section id="ack"><h2 id="rfc.section.unnumbered-1" class="np"><a href="#ack">Acknowledgements</a></h2><div id="rfc.section.unnumbered-1.p.1"><p>Eric Rescorla pointed out several failings in an earlier revision. Andrei Popov contributed to the TLS considerations.</p></div><div id="rfc.section.unnumbered-1.p.2"><p>A substantial portion of Mike’s work on this draft was supported by Microsoft during his employment there.</p></div></section><hr class="noprint"><section id="rfc.authors" class="np"><h2><a href="#rfc.authors">Authors' Addresses</a></h2><address><b>Mike Bishop</b><br>Akamai<br>EMail: <a href="mailto:mbishop@evequefou.be">mbishop@evequefou.be</a></address><address><b>Nick Sullivan</b><br>Cloudflare<br>EMail: <a href="mailto:nick@cloudflare.com">nick@cloudflare.com</a></address><address><b>Martin Thomson</b><br>Mozilla<br>EMail: <a href="mailto:martin.thomson@gmail.com">martin.thomson@gmail.com</a></address></section></body></html>

